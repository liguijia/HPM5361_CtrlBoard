/*
 * Copyright (c) 2023-2025 HPMicro
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#include "board.h"
#include "hpm_clock_drv.h"
#include "hpm_gpio_drv.h"
#include "hpm_i2c_drv.h"
#include "hpm_pcfg_drv.h"
#include "hpm_pllctlv2_drv.h"
#include "hpm_pwm_drv.h"
#include "hpm_sdk_version.h"
#include "hpm_soc.h"
#include "hpm_usb_drv.h"
#include "pinmux.h"
#include <stdio.h>

/**
 * @brief FLASH configuration option definitions:
 * option[0]:
 *    [31:16] 0xfcf9 - FLASH configuration option tag
 *    [15:4]  0 - Reserved
 *    [3:0]   option words (exclude option[0])
 * option[1]:
 *    [31:28] Flash probe type
 *      0 - SFDP SDR / 1 - SFDP DDR
 *      2 - 1-4-4 Read (0xEB, 24-bit address) / 3 - 1-2-2 Read(0xBB, 24-bit
 * address) 4 - HyperFLASH 1.8V / 5 - HyperFLASH 3V 6 - OctaBus DDR (SPI -> OPI
 * DDR) 8 - Xccela DDR (SPI -> OPI DDR) 10 - EcoXiP DDR (SPI -> OPI DDR) [27:24]
 * Command Pads after Power-on Reset 0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [23:20] Command Pads after Configuring FLASH
 *      0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [19:16] Quad Enable Sequence (for the device support SFDP 1.0 only)
 *      0 - Not needed
 *      1 - QE bit is at bit 6 in Status Register 1
 *      2 - QE bit is at bit1 in Status Register 2
 *      3 - QE bit is at bit7 in Status Register 2
 *      4 - QE bit is at bit1 in Status Register 2 and should be programmed by
 * 0x31 [15:8] Dummy cycles 0 - Auto-probed / detected / default value Others -
 * User specified value, for DDR read, the dummy cycles should be 2 * cycles on
 * FLASH datasheet [7:4] Misc. 0 - Not used 1 - SPI mode 2 - Internal loopback
 *      3 - External DQS
 *    [3:0] Frequency option
 *      1 - 30MHz / 2 - 50MHz / 3 - 66MHz / 4 - 80MHz / 5 - 100MHz / 6 - 114MHz
 * / 7 - 133MHz / 8 - 166MHz
 *
 * option[2] (Effective only if the bit[3:0] in option[0] > 1)
 *    [31:20]  Reserved
 *    [19:16] IO voltage
 *      0 - 3V / 1 - 1.8V
 *    [15:12] Pin group
 *      0 - 1st group / 1 - 2nd group
 *    [11:8] Connection selection
 *      0 - CA_CS0 / 1 - CB_CS0 / 2 - CA_CS0 + CB_CS0 (Two FLASH connected to CA
 * and CB respectively) [7:0] Drive Strength 0 - Default value option[3]
 * (Effective only if the bit[3:0] in option[0] > 2, required only for the QSPI
 * NOR FLASH that not supports JESD216) [31:16] reserved [15:12] Sector Erase
 * Command Option, not required here [11:8]  Sector Size Option, not required
 * here [7:0] Flash Size Option 0 - 4MB / 1 - 8MB / 2 - 16MB
 */

#if defined(FLASH_XIP) && FLASH_XIP
__attribute__((section(".nor_cfg_option"), used))
const uint32_t option[4] = {0xfcf90002, 0x00000005, 0x1000, 0x0};
#endif

#if defined(FLASH_UF2) && FLASH_UF2
ATTR_PLACE_AT(".uf2_signature")
__attribute__((used)) const uint32_t uf2_signature = BOARD_UF2_SIGNATURE;
#endif

void board_init_console(void) {
#if !defined(CONFIG_NDEBUG_CONSOLE) || !CONFIG_NDEBUG_CONSOLE
#if BOARD_CONSOLE_TYPE == CONSOLE_TYPE_UART
  console_config_t cfg;

  /* uart needs to configure pin function before enabling clock, otherwise the
   * level change of uart rx pin when configuring pin function will cause a
   * wrong data to be received. And a uart rx dma request will be generated by
   * default uart fifo dma trigger level.
   */
  init_uart_pins((UART_Type *)BOARD_CONSOLE_UART_BASE);

  clock_add_to_group(BOARD_CONSOLE_UART_CLK_NAME, 0);

  cfg.type = BOARD_CONSOLE_TYPE;
  cfg.base = (uint32_t)BOARD_CONSOLE_UART_BASE;
  cfg.src_freq_in_hz = clock_get_frequency(BOARD_CONSOLE_UART_CLK_NAME);
  cfg.baudrate = BOARD_CONSOLE_UART_BAUDRATE;

  if (status_success != console_init(&cfg)) {
    /* failed to  initialize debug console */
    while (1) {
    }
  }
#else
  while (1)
    ;
#endif
#endif
}

void board_print_banner(void) {
  const uint8_t banner[] =
      "\n"
      "----------------------------------------------------------------------\n"
      "$$\\   $$\\ $$$$$$$\\  $$\\      $$\\ $$\\\n"
      "$$ |  $$ |$$  __$$\\ $$$\\    $$$ |\\__|\n"
      "$$ |  $$ |$$ |  $$ |$$$$\\  $$$$ |$$\\  $$$$$$$\\  $$$$$$\\   $$$$$$\\\n"
      "$$$$$$$$ |$$$$$$$  |$$\\$$\\$$ $$ |$$ |$$  _____|$$  __$$\\ $$  __$$\\\n"
      "$$  __$$ |$$  ____/ $$ \\$$$  $$ |$$ |$$ /      $$ |  \\__|$$ /  $$ |\n"
      "$$ |  $$ |$$ |      $$ |\\$  /$$ |$$ |$$ |      $$ |      $$ |  $$ |\n"
      "$$ |  $$ |$$ |      $$ | \\_/ $$ |$$ |\\$$$$$$$\\ $$ |      \\$$$$$$  "
      "|\n"
      "\\__|  \\__|\\__|      \\__|     \\__|\\__| \\_______|\\__|       "
      "\\______/\n"
      "----------------------------------------------------------------------"
      "\n";
#ifdef SDK_VERSION_STRING
  printf("hpm_sdk: %s\n", SDK_VERSION_STRING);
#endif
  printf("%s", banner);
}

void board_print_clock_freq(void) {
  printf("==============================\n");
  printf(" %s clock summary\n", BOARD_NAME);
  printf("==============================\n");
  printf("cpu0:\t\t %luHz\n", clock_get_frequency(clock_cpu0));
  printf("ahb:\t\t %luHz\n", clock_get_frequency(clock_ahb));
  printf("mchtmr0:\t %luHz\n", clock_get_frequency(clock_mchtmr0));
  printf("xpi0:\t\t %luHz\n", clock_get_frequency(clock_xpi0));
  printf("==============================\n");
}

void board_init(void) {
  init_py_pins_as_pgpio();
  //
  board_init_clock();
  //
  board_init_gpio_pins();
  board_init_led_pins();
  //
  board_init_usb_dp_dm_pins();
  //
  board_init_console();
  board_print_clock_freq();
  board_print_banner();
}

void board_init_clock(void) {
  uint32_t cpu0_freq = clock_get_frequency(clock_cpu0);

  if (cpu0_freq == PLLCTL_SOC_PLL_REFCLK_FREQ) {
    /* Configure the External OSC ramp-up time: ~9ms */
    pllctlv2_xtal_set_rampup_time(HPM_PLLCTLV2, 32UL * 1000UL * 9U);

    /* Select clock setting preset1 */
    sysctl_clock_set_preset(HPM_SYSCTL, 2);
  }

  /* group0[0] */
  clock_add_to_group(clock_cpu0, 0);
  clock_add_to_group(clock_ahb, 0);
  clock_add_to_group(clock_lmm0, 0);
  clock_add_to_group(clock_mchtmr0, 0);
  clock_add_to_group(clock_rom, 0);
  clock_add_to_group(clock_mot0, 0);
  clock_add_to_group(clock_gpio, 0);
  clock_add_to_group(clock_hdma, 0);
  clock_add_to_group(clock_xpi0, 0);
  clock_add_to_group(clock_ptpc, 0);

  /* Connect Group0 to CPU0 */
  clock_connect_group_to_cpu(0, 0);

  /* Bump up DCDC voltage to 1275mv */
  pcfg_dcdc_set_voltage(HPM_PCFG, 1275);

  /* Configure CPU to 720MHz, AXI/AHB to 360MHz */
  sysctl_config_cpu0_domain_clock(HPM_SYSCTL, clock_source_pll0_clk0, 1, 2);
  /* Configure PLL0 Post Divider */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk0,
                       pllctlv2_div_1p0); /* PLL0CLK0: 960MHz */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk1,
                       pllctlv2_div_1p6); /* PLL0CLK1: 600MHz */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk2,
                       pllctlv2_div_2p4); /* PLL0CLK2: 400MHz */
  /* Configure PLL0 Frequency to 720MHz */
  pllctlv2_init_pll_with_freq(HPM_PLLCTLV2, pllctlv2_pll0, 720000000);

  clock_update_core_clock();

  /* Configure mchtmr to 24MHz */
  clock_set_source_divider(clock_mchtmr0, clk_src_osc24m, 1);
}

/* ---------------- USB ---------------- */

void board_init_usb_dp_dm_pins(void) {
  /* Disconnect usb dp/dm pins pull down 45ohm resistance */

  while (sysctl_resource_any_is_busy(HPM_SYSCTL)) {
  }

  if (pllctlv2_xtal_is_stable(HPM_PLLCTLV2) &&
      pllctlv2_xtal_is_enabled(HPM_PLLCTLV2)) {
    if (clock_check_in_group(clock_usb0, 0)) {
      usb_phy_disable_dp_dm_pulldown(HPM_USB0);
    } else {
      clock_add_to_group(clock_usb0, 0);
      usb_phy_disable_dp_dm_pulldown(HPM_USB0);
      clock_remove_from_group(clock_usb0, 0);
    }
  } else {
    uint8_t tmp;
    tmp = sysctl_resource_target_get_mode(HPM_SYSCTL, sysctl_resource_xtal);
    sysctl_resource_target_set_mode(HPM_SYSCTL, sysctl_resource_xtal, 0x03);
    clock_add_to_group(clock_usb0, 0);
    usb_phy_disable_dp_dm_pulldown(HPM_USB0);
    clock_remove_from_group(clock_usb0, 0);
    while (sysctl_resource_target_is_busy(HPM_SYSCTL, sysctl_resource_usb0)) {
    }
    sysctl_resource_target_set_mode(HPM_SYSCTL, sysctl_resource_xtal, tmp);
  }
}

void board_init_usb(USB_Type *ptr) {
  if (ptr == HPM_USB0) {
    // no USB_ID & USB_OC & USB_VBUS pinout in this board
    // init_usb_pins(ptr);
    clock_add_to_group(clock_usb0, 0);

    usb_hcd_set_power_ctrl_polarity(ptr, true);
    board_delay_ms(100);

    usb_phy_using_internal_vbus(ptr);
  }
}

/* ---------------- CAN ---------------- */

uint32_t board_init_can_clock(MCAN_Type *ptr) {
  uint32_t freq = 0;
  if (ptr == HPM_MCAN0) {
    clock_add_to_group(clock_can0, 0);
    clock_set_source_divider(clock_can0, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can0);
  } else if (ptr == HPM_MCAN1) {
    clock_add_to_group(clock_can1, 0);
    clock_set_source_divider(clock_can1, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can1);
  } else if (ptr == HPM_MCAN2) {
    clock_add_to_group(clock_can2, 0);
    clock_set_source_divider(clock_can2, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can2);
  } else if (ptr == HPM_MCAN3) {
    clock_add_to_group(clock_can3, 0);
    clock_set_source_divider(clock_can3, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can3);
  }
  return freq;
}

void board_init_can(MCAN_Type *ptr) {
  init_can_pins(ptr);
  board_init_can_clock(ptr);
}

/* ---------------- UART ---------------- */

uint32_t board_init_uart_clock(UART_Type *ptr) {
  uint32_t freq = 0U;
  if (ptr == HPM_UART0) {
    clock_add_to_group(clock_uart0, 0);
    freq = clock_get_frequency(clock_uart0);
  } else if (ptr == HPM_UART1) {
    clock_add_to_group(clock_uart1, 0);
    freq = clock_get_frequency(clock_uart1);
  } else if (ptr == HPM_UART2) {
    clock_add_to_group(clock_uart2, 0);
    freq = clock_get_frequency(clock_uart2);
  } else if (ptr == HPM_UART3) {
    clock_add_to_group(clock_uart3, 0);
    freq = clock_get_frequency(clock_uart3);
  } else if (ptr == HPM_UART4) {
    clock_add_to_group(clock_uart4, 0);
    freq = clock_get_frequency(clock_uart4);
  } else if (ptr == HPM_UART5) {
    clock_add_to_group(clock_uart5, 0);
    freq = clock_get_frequency(clock_uart5);
  }
  return freq;
}

void board_init_uart(UART_Type *ptr) {
  init_uart_pins(ptr);
  board_init_uart_clock(ptr);
}

/* ---------------- SPI ---------------- */

uint32_t board_init_spi_clock(SPI_Type *ptr) {
  if (ptr == HPM_SPI1) {
    clock_add_to_group(clock_spi1, 0);
    return clock_get_frequency(clock_spi1);
  } else if (ptr == HPM_SPI2) {
    clock_add_to_group(clock_spi2, 0);
    return clock_get_frequency(clock_spi2);
  } else if (ptr == HPM_SPI3) {
    clock_add_to_group(clock_spi3, 0);
    return clock_get_frequency(clock_spi3);
  }
  return 0;
}

void board_init_spi_pins(SPI_Type *ptr) {
  init_spi_pins(ptr);
  board_init_spi_clock(ptr);
}

/* ---------------- I2C ---------------- */

uint32_t board_init_i2c_clock(I2C_Type *ptr) {
  uint32_t freq = 0;
  if (ptr == HPM_I2C0) {
    clock_add_to_group(clock_i2c0, 0);
    freq = clock_get_frequency(clock_i2c0);
  }
  return freq;
}

void board_i2c_bus_clear(I2C_Type *ptr) {
  if (i2c_get_line_scl_status(ptr) == false) {
    while (1) {
    }
  }
  if (i2c_get_line_sda_status(ptr) == false) {
  } else {
    return;
  }
  i2c_gen_reset_signal(ptr, 9);
  board_delay_ms(100);
}

void board_init_i2c(I2C_Type *ptr) {
  i2c_config_t config;
  hpm_stat_t stat;
  uint32_t freq;

  freq = board_init_i2c_clock(ptr);
  init_i2c_pins(ptr);
  board_i2c_bus_clear(ptr);
  config.i2c_mode = i2c_mode_normal;
  config.is_10bit_addressing = false;
  stat = i2c_init_master(ptr, freq, &config);
  if (stat != status_success) {
    while (1) {
    }
  }
}

/* ========================================================================== */
/*                    Shared PWM0 arbitration and state                       */
/* ========================================================================== */

/* RGB LED 状态 */
static bool rgb_pwm_inited = false;
static float rgb_last_r = 0.0f;
static float rgb_last_g = 0.0f;
static float rgb_last_b = 0.0f;

/* 蜂鸣器状态 */
static bool buzzer_pwm_inited = false;
static bool buzzer_enabled = false;
static uint32_t buzzer_target_hz = 0U;

/* pinsocket 状态（PWM0 ch0~3） */
static bool pinsocket_pwm_inited = false;
static bool pinsocket_channel_enabled[4] = {false, false, false, false};
static float pinsocket_last_duty[4] = {0.0f, 0.0f, 0.0f, 0.0f};

/* PWM0 全局时钟/周期缓存（避免频繁调用 clock_get_frequency） */
static uint32_t pwm0_src_clk = 0U;
static uint32_t pwm0_reload = 0U;

/* 获取 PWM0 时钟频率 */
static void pwm0_init_src_clk(void) {
  if (pwm0_src_clk == 0U) {
    pwm0_src_clk = clock_get_frequency(clock_mot0);
    if (pwm0_src_clk == 0U) {
      pwm0_src_clk = 1U; /* 防止除零 */
    }
  }
}

/* pinsocket 是否有任意通道正在输出 */
static bool pinsocket_any_channel_enabled(void) {
  if (!pinsocket_pwm_inited) {
    return false;
  }
  for (uint8_t ch = 0; ch < 4U; ch++) {
    if (pinsocket_channel_enabled[ch]) {
      return true;
    }
  }
  return false;
}

/**
 * @brief 统一设置 PWM0 频率，并根据各外设“最后状态”同步所有通道
 *
 * 优先级在上层逻辑决定，这里只负责：
 *  - 修改 reload（全局频率）
 *  - 重新写入 pinsocket / RGB / buzzer 的占空比
 *  - 启动计数器、按状态 enable/disable 对应通道
 */
static void pwm0_update_period_and_sync(uint32_t target_hz) {
  if (target_hz == 0U) {
    return;
  }

  pwm0_init_src_clk();

  uint32_t new_reload = pwm0_src_clk / target_hz;
  if (new_reload == 0U) {
    new_reload = 1U;
  }
  new_reload -= 1U;

  if (new_reload != pwm0_reload) {
    pwm_stop_counter(HPM_PWM0);
    pwm_set_reload(HPM_PWM0, 0, new_reload);
    pwm_set_start_count(HPM_PWM0, 0, 0);
    pwm0_reload = new_reload;
  }

  /* pinsocket ch0~3 */
  if (pinsocket_pwm_inited) {
    for (uint8_t ch = 0; ch < 4U; ch++) {
      float duty =
          pinsocket_channel_enabled[ch] ? pinsocket_last_duty[ch] : 0.0f;
      pwm_update_duty_edge_aligned(HPM_PWM0, ch, duty);
    }
  }

  /* RGB：ch4~6 */
  if (rgb_pwm_inited) {
    pwm_update_duty_edge_aligned(HPM_PWM0, 6, rgb_last_r);
    pwm_update_duty_edge_aligned(HPM_PWM0, 5, rgb_last_g);
    pwm_update_duty_edge_aligned(HPM_PWM0, 4, rgb_last_b);
  }

  /* 蜂鸣器：ch7 固定 50% 占空比 */
  if (buzzer_pwm_inited && buzzer_enabled) {
    pwm_update_raw_cmp_edge_aligned(HPM_PWM0, 7, pwm0_reload / 2U);
  }

  pwm_issue_shadow_register_lock_event(HPM_PWM0);
  pwm_start_counter(HPM_PWM0);

  /* enable/disable 各通道 */
  if (pinsocket_pwm_inited) {
    for (uint8_t ch = 0; ch < 4U; ch++) {
      if (pinsocket_channel_enabled[ch]) {
        pwm_enable_output(HPM_PWM0, ch);
      } else {
        pwm_disable_output(HPM_PWM0, ch);
      }
    }
  }

  if (rgb_pwm_inited) {
    pwm_enable_output(HPM_PWM0, 4);
    pwm_enable_output(HPM_PWM0, 5);
    pwm_enable_output(HPM_PWM0, 6);
  }

  if (buzzer_pwm_inited) {
    if (buzzer_enabled) {
      pwm_enable_output(HPM_PWM0, 7);
    } else {
      pwm_disable_output(HPM_PWM0, 7);
    }
  }
}

/* ========================================================================== */
/*                                RGB LED                                     */
/* ========================================================================== */

void board_init_rgbled(void) {
  pwm_config_t pwm_cfg;
  pwm_cmp_config_t cmp_cfg = {0};

  init_rgbled_pwm_pins();

  /* 若 PWM0 当前未被 pinsocket/buzzer 使用，则由 RGB 设置一个默认频率；
     否则仅挂载通道，不改变全局频率 */
  bool pwm_in_use = pinsocket_pwm_inited || buzzer_pwm_inited;

  if (!pwm_in_use && (pwm0_reload == 0U)) {
    /* 默认 10 kHz */
    pwm0_update_period_and_sync(10000U);
  }

  pwm_get_default_pwm_config(HPM_PWM0, &pwm_cfg);
  pwm_cfg.enable_output = true;
  pwm_cfg.invert_output = false;
  pwm_cfg.dead_zone_in_half_cycle = 0;

  pwm_get_default_cmp_config(HPM_PWM0, &cmp_cfg);
  cmp_cfg.mode = pwm_cmp_mode_output_compare;
  cmp_cfg.cmp = 0; /* 初始占空比 0% */
  cmp_cfg.update_trigger = pwm_shadow_register_update_on_modify;

  /* ch4(B), ch5(G), ch6(R) */
  pwm_setup_waveform(HPM_PWM0, 4, &pwm_cfg, 4, &cmp_cfg, 1);
  pwm_setup_waveform(HPM_PWM0, 5, &pwm_cfg, 5, &cmp_cfg, 1);
  pwm_setup_waveform(HPM_PWM0, 6, &pwm_cfg, 6, &cmp_cfg, 1);

  pwm_enable_output(HPM_PWM0, 4);
  pwm_enable_output(HPM_PWM0, 5);
  pwm_enable_output(HPM_PWM0, 6);

  rgb_pwm_inited = true;
}

void board_set_rgbled_color(float r, float g, float b) {
  if (!rgb_pwm_inited) {
    board_init_rgbled();
  }

  rgb_last_r = r;
  rgb_last_g = g;
  rgb_last_b = b;

  pwm_update_duty_edge_aligned(HPM_PWM0, 6, r);
  pwm_update_duty_edge_aligned(HPM_PWM0, 5, g);
  pwm_update_duty_edge_aligned(HPM_PWM0, 4, b);
  pwm_issue_shadow_register_lock_event(HPM_PWM0);
}

/* ========================================================================== */
/*                                 Buzzer                                     */
/* ========================================================================== */

void board_init_buzzer(void) {
  pwm_config_t pwm_cfg;
  pwm_cmp_config_t cmp_cfg;

  init_buzzer_pwm_pin();

  pwm_get_default_pwm_config(HPM_PWM0, &pwm_cfg);
  pwm_cfg.enable_output = true;
  pwm_cfg.invert_output = false;
  pwm_cfg.dead_zone_in_half_cycle = 0;

  pwm_get_default_cmp_config(HPM_PWM0, &cmp_cfg);
  cmp_cfg.mode = pwm_cmp_mode_output_compare;
  cmp_cfg.update_trigger = pwm_shadow_register_update_on_modify;
  cmp_cfg.cmp = 0; /* 初始占空比 0 */

  /* 使用 CMP7 控制 ch7 */
  pwm_setup_waveform(HPM_PWM0, 7, &pwm_cfg, 7, &cmp_cfg, 1);

  buzzer_pwm_inited = true;
}

void board_set_buzzer_freq(bool enable, uint32_t freq_in_hz) {
  if (!enable || (freq_in_hz == 0U)) {
    buzzer_enabled = false;
    buzzer_target_hz = 0U;
    if (buzzer_pwm_inited) {
      pwm_disable_output(HPM_PWM0, 7);
    }
    /* 不再强制恢复 RGB/pinsocket 频率，保持当前配置 */
    return;
  }

  if (!buzzer_pwm_inited) {
    board_init_buzzer();
  }

  buzzer_enabled = true;
  buzzer_target_hz = freq_in_hz;

  if (pinsocket_any_channel_enabled()) {
    /* 有 pinsocket 在工作：pinsocket 优先，禁止修改全局频率。
       在当前 pwm0_reload 上输出 50% duty。 */
    if (pwm0_reload == 0U) {
      /* 理论上不会发生，因为 pinsocket 设置频率必经 pwm0_update_period_and_sync
       */
      pwm0_init_src_clk();
      pwm0_reload = (pwm0_src_clk / freq_in_hz) - 1U;
    }

    pwm_update_raw_cmp_edge_aligned(HPM_PWM0, 7, pwm0_reload / 2U);
    pwm_issue_shadow_register_lock_event(HPM_PWM0);
    pwm_enable_output(HPM_PWM0, 7);

    /* 若 RGB 已经初始化，仅恢复占空比，不触发重新初始化 */
    if (rgb_pwm_inited) {
      pwm_update_duty_edge_aligned(HPM_PWM0, 6, rgb_last_r);
      pwm_update_duty_edge_aligned(HPM_PWM0, 5, rgb_last_g);
      pwm_update_duty_edge_aligned(HPM_PWM0, 4, rgb_last_b);
      pwm_issue_shadow_register_lock_event(HPM_PWM0);
    }
  } else {
    /* 无 pinsocket 时，buzzer 可以接管频率 */
    pwm0_update_period_and_sync(freq_in_hz);
  }
}

/* ========================================================================== */
/*                               IMU Heater                                   */
/* ========================================================================== */

void board_init_imuheater(void) { init_imuheater_pwm_pin(); }

void board_set_imuheater_power(uint8_t power_percent) {
  // TODO: 根据实际硬件设计实现
}

/* ========================================================================== */
/*                             Pinsocket PWM                                  */
/* ========================================================================== */

void board_init_pinsocket_pwmout(void) {
  if (pinsocket_pwm_inited) {
    return;
  }

  pwm_config_t pwm_cfg;
  pwm_cmp_config_t cmp_cfg;

  init_pinsocket_pwm_pins();

  pwm_get_default_pwm_config(HPM_PWM0, &pwm_cfg);
  pwm_cfg.enable_output = true;
  pwm_cfg.invert_output = false;
  pwm_cfg.dead_zone_in_half_cycle = 0;

  pwm_get_default_cmp_config(HPM_PWM0, &cmp_cfg);
  cmp_cfg.mode = pwm_cmp_mode_output_compare;
  cmp_cfg.update_trigger = pwm_shadow_register_update_on_modify;
  cmp_cfg.cmp = 0;

  for (uint8_t ch = 0; ch < 4U; ch++) {
    pwm_setup_waveform(HPM_PWM0, ch, &pwm_cfg, ch, &cmp_cfg, 1);
    pinsocket_channel_enabled[ch] = false;
    pinsocket_last_duty[ch] = 0.0f;
    pwm_disable_output(HPM_PWM0, ch);
  }

  pinsocket_pwm_inited = true;
}

/**
 * @brief pinsocket PWM 输出控制
 *
 * 优先级：pinsocket > buzzer > RGB
 *  - 任一 pinsocket 通道 enable 时，由 pinsocket 接管 PWM0 频率；
 *  - 所有 pinsocket 通道 disable 后，若 buzzer 仍 enable，则交还给 buzzer；
 *  - 再无 buzzer 时，仅 RGB 使用时才由 RGB 设默认频率。
 */
void board_set_pinsocket_pwmout(bool enable, uint8_t channel,
                                uint32_t freq_in_hz, float duty_cycle_percent) {
  if (channel >= 4U) {
    return;
  }

  if (!pinsocket_pwm_inited) {
    board_init_pinsocket_pwmout();
  }

  if (!enable || (freq_in_hz == 0U) || (duty_cycle_percent <= 0.0f)) {
    /* 关闭指定通道 */
    pwm_disable_output(HPM_PWM0, channel);
    pinsocket_channel_enabled[channel] = false;
    pinsocket_last_duty[channel] = 0.0f;

    if (!pinsocket_any_channel_enabled()) {
      /* 所有 pinsocket 通道都关闭了 */
      if (buzzer_enabled && (buzzer_target_hz > 0U)) {
        /* 若蜂鸣器仍启用，则恢复其目标频率 */
        pwm0_update_period_and_sync(buzzer_target_hz);
      } else {
        /* 否则保持当前频率（RGB 对频率不敏感） */
      }
    }
    return;
  }

  /* enable = true, 且具备有效频率和占空比 */

  float duty = duty_cycle_percent;
  if (duty > 100.0f) {
    duty = 100.0f;
  }

  pinsocket_channel_enabled[channel] = true;
  pinsocket_last_duty[channel] = duty;

  /* 判断是否已有其他 pinsocket 通道在工作 */
  bool other_active = false;
  for (uint8_t ch = 0; ch < 4U; ch++) {
    if ((ch != channel) && pinsocket_channel_enabled[ch]) {
      other_active = true;
      break;
    }
  }

  if (!other_active) {
    /* 当前是“第一个/唯一”启用的 pinsocket 通道：由 pinsocket 接管 PWM0 频率 */
    pwm0_update_period_and_sync(freq_in_hz);
  } else {
    /* 已有其它 pinsocket 通道在输出：禁止修改频率，仅设置本通道占空比 */
    pwm_update_duty_edge_aligned(HPM_PWM0, channel, duty);
    pwm_issue_shadow_register_lock_event(HPM_PWM0);
  }

  /* 再统一 enable/disable 各 pinsocket 通道 */
  for (uint8_t ch = 0; ch < 4U; ch++) {
    if (pinsocket_channel_enabled[ch]) {
      pwm_enable_output(HPM_PWM0, ch);
    } else {
      pwm_disable_output(HPM_PWM0, ch);
    }
  }

  /* 若蜂鸣器启用，则在当前频率上维持 50% 占空比 */
  if (buzzer_enabled && buzzer_pwm_inited) {
    pwm_update_raw_cmp_edge_aligned(HPM_PWM0, 7, pwm0_reload / 2U);
    pwm_enable_output(HPM_PWM0, 7);
    pwm_issue_shadow_register_lock_event(HPM_PWM0);
  }
}

/* ========================================================================== */
/*                          User key / switch / delay                         */
/* ========================================================================== */

void board_init_user_key(void) { init_user_key_pin(); }

bool board_get_user_key_status(void) {
  return gpio_read_pin(HPM_GPIO0, GPIO_DI_GPIOY, 3) == 0;
}

void board_init_user_sw(void) { init_user_sw_pin(); }

bool board_get_user_sw_status(void) {
  return gpio_read_pin(HPM_GPIO0, GPIO_DI_GPIOY, 4) != 0;
}

/* board delay functions */
void board_delay_us(uint32_t us) { clock_cpu_delay_us(us); }

void board_delay_ms(uint32_t ms) { clock_cpu_delay_ms(ms); }

/* TODO Remove - hpm5300evk config，if not use hpm5300evk */
void board_init_gpio_pins(void) {
  init_gpio_pins();
  gpio_set_pin_input(BOARD_APP_GPIO_CTRL, BOARD_APP_GPIO_INDEX,
                     BOARD_APP_GPIO_PIN);
}

void board_init_led_pins(void) {
  init_led_pins_as_gpio();
  gpio_set_pin_output_with_initial(BOARD_LED_GPIO_CTRL, BOARD_LED_GPIO_INDEX,
                                   BOARD_LED_GPIO_PIN, BOARD_LED_OFF_LEVEL);
}
