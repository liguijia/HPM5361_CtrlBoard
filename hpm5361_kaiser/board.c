/*
 * Copyright (c) 2023-2025 HPMicro
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

#include "board.h"
#include "hpm_clock_drv.h"
#include "hpm_gpio_drv.h"
#include "hpm_i2c_drv.h"
#include "hpm_pcfg_drv.h"
#include "hpm_pllctlv2_drv.h"
#include "hpm_pwm_drv.h"
#include "hpm_sdk_version.h"
#include "hpm_soc.h"
#include "hpm_usb_drv.h"
#include "pinmux.h"
#include <stdio.h>
/**
 * @brief FLASH configuration option definitions:
 * option[0]:
 *    [31:16] 0xfcf9 - FLASH configuration option tag
 *    [15:4]  0 - Reserved
 *    [3:0]   option words (exclude option[0])
 * option[1]:
 *    [31:28] Flash probe type
 *      0 - SFDP SDR / 1 - SFDP DDR
 *      2 - 1-4-4 Read (0xEB, 24-bit address) / 3 - 1-2-2 Read(0xBB, 24-bit
 * address) 4 - HyperFLASH 1.8V / 5 - HyperFLASH 3V 6 - OctaBus DDR (SPI -> OPI
 * DDR) 8 - Xccela DDR (SPI -> OPI DDR) 10 - EcoXiP DDR (SPI -> OPI DDR) [27:24]
 * Command Pads after Power-on Reset 0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [23:20] Command Pads after Configuring FLASH
 *      0 - SPI / 1 - DPI / 2 - QPI / 3 - OPI
 *    [19:16] Quad Enable Sequence (for the device support SFDP 1.0 only)
 *      0 - Not needed
 *      1 - QE bit is at bit 6 in Status Register 1
 *      2 - QE bit is at bit1 in Status Register 2
 *      3 - QE bit is at bit7 in Status Register 2
 *      4 - QE bit is at bit1 in Status Register 2 and should be programmed by
 * 0x31 [15:8] Dummy cycles 0 - Auto-probed / detected / default value Others -
 * User specified value, for DDR read, the dummy cycles should be 2 * cycles on
 * FLASH datasheet [7:4] Misc. 0 - Not used 1 - SPI mode 2 - Internal loopback
 *      3 - External DQS
 *    [3:0] Frequency option
 *      1 - 30MHz / 2 - 50MHz / 3 - 66MHz / 4 - 80MHz / 5 - 100MHz / 6 - 114MHz
 * / 7 - 133MHz / 8 - 166MHz
 *
 * option[2] (Effective only if the bit[3:0] in option[0] > 1)
 *    [31:20]  Reserved
 *    [19:16] IO voltage
 *      0 - 3V / 1 - 1.8V
 *    [15:12] Pin group
 *      0 - 1st group / 1 - 2nd group
 *    [11:8] Connection selection
 *      0 - CA_CS0 / 1 - CB_CS0 / 2 - CA_CS0 + CB_CS0 (Two FLASH connected to CA
 * and CB respectively) [7:0] Drive Strength 0 - Default value option[3]
 * (Effective only if the bit[3:0] in option[0] > 2, required only for the QSPI
 * NOR FLASH that not supports JESD216) [31:16] reserved [15:12] Sector Erase
 * Command Option, not required here [11:8]  Sector Size Option, not required
 * here [7:0] Flash Size Option 0 - 4MB / 1 - 8MB / 2 - 16MB
 */

#if defined(FLASH_XIP) && FLASH_XIP
__attribute__((section(".nor_cfg_option"), used))
const uint32_t option[4] = {0xfcf90002, 0x00000005, 0x1000, 0x0};
#endif

#if defined(FLASH_UF2) && FLASH_UF2
ATTR_PLACE_AT(".uf2_signature")
__attribute__((used)) const uint32_t uf2_signature = BOARD_UF2_SIGNATURE;
#endif

void board_init_console(void) {
#if !defined(CONFIG_NDEBUG_CONSOLE) || !CONFIG_NDEBUG_CONSOLE
#if BOARD_CONSOLE_TYPE == CONSOLE_TYPE_UART
  console_config_t cfg;

  /* uart needs to configure pin function before enabling clock, otherwise the
   * level change of uart rx pin when configuring pin function will cause a
   * wrong data to be received. And a uart rx dma request will be generated by
   * default uart fifo dma trigger level.
   */
  init_uart_pins((UART_Type *)BOARD_CONSOLE_UART_BASE);

  clock_add_to_group(BOARD_CONSOLE_UART_CLK_NAME, 0);

  cfg.type = BOARD_CONSOLE_TYPE;
  cfg.base = (uint32_t)BOARD_CONSOLE_UART_BASE;
  cfg.src_freq_in_hz = clock_get_frequency(BOARD_CONSOLE_UART_CLK_NAME);
  cfg.baudrate = BOARD_CONSOLE_UART_BAUDRATE;

  if (status_success != console_init(&cfg)) {
    /* failed to  initialize debug console */
    while (1) {
    }
  }
#else
  while (1)
    ;
#endif
#endif
}

void board_print_banner(void) {
  const uint8_t banner[] =
      "\n"
      "----------------------------------------------------------------------\n"
      "$$\\   $$\\ $$$$$$$\\  $$\\      $$\\ $$\\\n"
      "$$ |  $$ |$$  __$$\\ $$$\\    $$$ |\\__|\n"
      "$$ |  $$ |$$ |  $$ |$$$$\\  $$$$ |$$\\  $$$$$$$\\  $$$$$$\\   $$$$$$\\\n"
      "$$$$$$$$ |$$$$$$$  |$$\\$$\\$$ $$ |$$ |$$  _____|$$  __$$\\ $$  __$$\\\n"
      "$$  __$$ |$$  ____/ $$ \\$$$  $$ |$$ |$$ /      $$ |  \\__|$$ /  $$ |\n"
      "$$ |  $$ |$$ |      $$ |\\$  /$$ |$$ |$$ |      $$ |      $$ |  $$ |\n"
      "$$ |  $$ |$$ |      $$ | \\_/ $$ |$$ |\\$$$$$$$\\ $$ |      \\$$$$$$  "
      "|\n"
      "\\__|  \\__|\\__|      \\__|     \\__|\\__| \\_______|\\__|       "
      "\\______/\n"
      "----------------------------------------------------------------------"
      "\n";
#ifdef SDK_VERSION_STRING
  printf("hpm_sdk: %s\n", SDK_VERSION_STRING);
#endif
  printf("%s", banner);
}

void board_print_clock_freq(void) {
  printf("==============================\n");
  printf(" %s clock summary\n", BOARD_NAME);
  printf("==============================\n");
  printf("cpu0:\t\t %luHz\n", clock_get_frequency(clock_cpu0));
  printf("ahb:\t\t %luHz\n", clock_get_frequency(clock_ahb));
  printf("mchtmr0:\t %luHz\n", clock_get_frequency(clock_mchtmr0));
  printf("xpi0:\t\t %luHz\n", clock_get_frequency(clock_xpi0));
  printf("==============================\n");
}

void board_init(void) {
  init_py_pins_as_pgpio();
  //
  board_init_clock();
  //
  board_init_gpio_pins();
  board_init_led_pins();
  //
  board_init_usb_dp_dm_pins();
  //
  board_init_console();
  board_print_clock_freq();
  board_print_banner();
}

void board_init_clock(void) {
  uint32_t cpu0_freq = clock_get_frequency(clock_cpu0);

  if (cpu0_freq == PLLCTL_SOC_PLL_REFCLK_FREQ) {
    /* Configure the External OSC ramp-up time: ~9ms */
    pllctlv2_xtal_set_rampup_time(HPM_PLLCTLV2, 32UL * 1000UL * 9U);

    /* Select clock setting preset1 */
    sysctl_clock_set_preset(HPM_SYSCTL, 2);
  }

  /* group0[0] */
  clock_add_to_group(clock_cpu0, 0);
  clock_add_to_group(clock_ahb, 0);
  clock_add_to_group(clock_lmm0, 0);
  clock_add_to_group(clock_mchtmr0, 0);
  clock_add_to_group(clock_rom, 0);
  clock_add_to_group(clock_mot0, 0);
  clock_add_to_group(clock_gpio, 0);
  clock_add_to_group(clock_hdma, 0);
  clock_add_to_group(clock_xpi0, 0);
  clock_add_to_group(clock_ptpc, 0);

  /* Connect Group0 to CPU0 */
  clock_connect_group_to_cpu(0, 0);

  /* Bump up DCDC voltage to 1275mv */
  pcfg_dcdc_set_voltage(HPM_PCFG, 1275);

  /* Configure CPU to 720MHz, AXI/AHB to 360MHz */
  sysctl_config_cpu0_domain_clock(HPM_SYSCTL, clock_source_pll0_clk0, 1, 2);
  /* Configure PLL0 Post Divider */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk0,
                       pllctlv2_div_1p0); /* PLL0CLK0: 960MHz */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk1,
                       pllctlv2_div_1p6); /* PLL0CLK1: 600MHz */
  pllctlv2_set_postdiv(HPM_PLLCTLV2, pllctlv2_pll0, pllctlv2_clk2,
                       pllctlv2_div_2p4); /* PLL0CLK2: 400MHz */
  /* Configure PLL0 Frequency to 720MHz */
  pllctlv2_init_pll_with_freq(HPM_PLLCTLV2, pllctlv2_pll0, 720000000);

  clock_update_core_clock();

  /* Configure mchtmr to 24MHz */
  clock_set_source_divider(clock_mchtmr0, clk_src_osc24m, 1);
}

// board usb initialization
/**
 * @brief board_init_usb_dp_dm_pins
 *
 */
void board_init_usb_dp_dm_pins(void) {
  /* Disconnect usb dp/dm pins pull down 45ohm resistance */

  while (sysctl_resource_any_is_busy(HPM_SYSCTL)) {
  }

  if (pllctlv2_xtal_is_stable(HPM_PLLCTLV2) &&
      pllctlv2_xtal_is_enabled(HPM_PLLCTLV2)) {
    if (clock_check_in_group(clock_usb0, 0)) {
      usb_phy_disable_dp_dm_pulldown(HPM_USB0);
    } else {
      clock_add_to_group(clock_usb0, 0);
      usb_phy_disable_dp_dm_pulldown(HPM_USB0);
      clock_remove_from_group(clock_usb0, 0);
    }
  } else {
    uint8_t tmp;
    tmp = sysctl_resource_target_get_mode(HPM_SYSCTL, sysctl_resource_xtal);
    sysctl_resource_target_set_mode(HPM_SYSCTL, sysctl_resource_xtal, 0x03);
    clock_add_to_group(clock_usb0, 0);
    usb_phy_disable_dp_dm_pulldown(HPM_USB0);
    clock_remove_from_group(clock_usb0, 0);
    while (sysctl_resource_target_is_busy(HPM_SYSCTL, sysctl_resource_usb0)) {
    }
    sysctl_resource_target_set_mode(HPM_SYSCTL, sysctl_resource_xtal, tmp);
  }
}
/**
 * @brief board_init_usb
 *
 * @param ptr USB_Type*
 */
void board_init_usb(USB_Type *ptr) {
  if (ptr == HPM_USB0) {
    // no USB_ID & USB_OC & USB_VBUS pinout in this board
    // init_usb_pins(ptr);
    clock_add_to_group(clock_usb0, 0);

    usb_hcd_set_power_ctrl_polarity(ptr, true);
    board_delay_ms(100);

    usb_phy_using_internal_vbus(ptr);
  }
}
// board can initialization

uint32_t board_init_can_clock(MCAN_Type *ptr) {
  uint32_t freq = 0;
  if (ptr == HPM_MCAN0) {
    clock_add_to_group(clock_can0, 0);
    clock_set_source_divider(clock_can0, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can0);
  } else if (ptr == HPM_MCAN1) {
    clock_add_to_group(clock_can1, 0);
    clock_set_source_divider(clock_can1, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can1);
  } else if (ptr == HPM_MCAN2) {
    clock_add_to_group(clock_can2, 0);
    clock_set_source_divider(clock_can2, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can2);
  } else if (ptr == HPM_MCAN3) {
    clock_add_to_group(clock_can3, 0);
    clock_set_source_divider(clock_can3, clk_src_pll1_clk0, 10);
    freq = clock_get_frequency(clock_can3);
  }
  return freq;
}
void board_init_can(MCAN_Type *ptr) {
  init_can_pins(ptr);
  board_init_can_clock(ptr);
}
// board uart initialization
/**
 * @brief board_init_uart_clock
 *
 * @param ptr UART_Type*
 * @return uint32_t uart clock frequency
 */
uint32_t board_init_uart_clock(UART_Type *ptr) {
  uint32_t freq = 0U;
  if (ptr == HPM_UART0) {
    clock_add_to_group(clock_uart0, 0);
    freq = clock_get_frequency(clock_uart0);
  } else if (ptr == HPM_UART1) {
    clock_add_to_group(clock_uart1, 0);
    freq = clock_get_frequency(clock_uart1);
  } else if (ptr == HPM_UART2) {
    clock_add_to_group(clock_uart2, 0);
    freq = clock_get_frequency(clock_uart2);
  } else if (ptr == HPM_UART3) {
    clock_add_to_group(clock_uart3, 0);
    freq = clock_get_frequency(clock_uart3);
  } else if (ptr == HPM_UART4) {
    clock_add_to_group(clock_uart4, 0);
    freq = clock_get_frequency(clock_uart4);
  } else if (ptr == HPM_UART5) {
    clock_add_to_group(clock_uart5, 0);
    freq = clock_get_frequency(clock_uart5);
  }
  return freq;
}
/**
 * @brief board_init_uart
 *
 * @param ptr UART_Type*
 */
void board_init_uart(UART_Type *ptr) {
  init_uart_pins(ptr);
  board_init_uart_clock(ptr);
}

// board spi initialization
/**
 * @brief board_init_spi_clock
 * @param ptr SPI_Type*
 * @return uint32_t spi clock frequency
 */
uint32_t board_init_spi_clock(SPI_Type *ptr) {
  if (ptr == HPM_SPI1) {
    clock_add_to_group(clock_spi1, 0);
    return clock_get_frequency(clock_spi1);
  } else if (ptr == HPM_SPI2) {
    clock_add_to_group(clock_spi2, 0);
    return clock_get_frequency(clock_spi2);
  } else if (ptr == HPM_SPI3) {
    clock_add_to_group(clock_spi3, 0);
    return clock_get_frequency(clock_spi3);
  }
  return 0;
}
/**
 * @brief board_init_spi_pins
 * @param ptr SPI_Type*
 */
void board_init_spi_pins(SPI_Type *ptr) {
  init_spi_pins(ptr);
  board_init_spi_clock(ptr);
}

// board i2c initialization
/**
 * @brief board_init_i2c_clock
 * @param ptr I2C_Type*
 * @return uint32_t i2c clock frequency
 */
uint32_t board_init_i2c_clock(I2C_Type *ptr) {
  uint32_t freq = 0;
  if (ptr == HPM_I2C0) {
    clock_add_to_group(clock_i2c0, 0);
    freq = clock_get_frequency(clock_i2c0);
  }
  return freq;
}
/**
 * @brief board_init_i2c
 * @param ptr I2C_Type*
 */
void board_i2c_bus_clear(I2C_Type *ptr) {
  if (i2c_get_line_scl_status(ptr) == false) {
    while (1) {
    }
  }
  if (i2c_get_line_sda_status(ptr) == false) {
  } else {
    return;
  }
  i2c_gen_reset_signal(ptr, 9);
  board_delay_ms(100);
}
/**
 * @brief board_init_i2c
 * @param ptr I2C_Type*
 */
void board_init_i2c(I2C_Type *ptr) {
  i2c_config_t config;
  hpm_stat_t stat;
  uint32_t freq;

  freq = board_init_i2c_clock(ptr);
  init_i2c_pins(ptr);
  board_i2c_bus_clear(ptr);
  config.i2c_mode = i2c_mode_normal;
  config.is_10bit_addressing = false;
  stat = i2c_init_master(ptr, freq, &config);
  if (stat != status_success) {
    while (1) {
    }
  }
}

/*  other board functions */

// board RGB LED
static bool rgb_pwm_inited = false;
static uint32_t rgb_reload;
static float rgb_last_r;
static float rgb_last_g;
static float rgb_last_b;
void board_init_rgbled(void) {
  pwm_config_t pwm_cfg;
  pwm_cmp_config_t cmp_cfg = {0};
  // init pwm pins
  init_rgbled_pwm_pins();
  // Deinitialize PWM0 before configuration
  pwm_deinit(HPM_PWM0);
  pwm_stop_counter(HPM_PWM0);
  //
  // configure pwm
  uint32_t freq = clock_get_frequency(clock_mot0);
  rgb_reload = freq / 10000 - 1U;
  // configure pwm
  pwm_get_default_pwm_config(HPM_PWM0, &pwm_cfg);
  pwm_cfg.enable_output = true;
  pwm_cfg.invert_output = false;
  pwm_cfg.dead_zone_in_half_cycle = 0;
  //
  pwm_stop_counter(HPM_PWM0);
  pwm_set_reload(HPM_PWM0, 0, rgb_reload);
  pwm_set_start_count(HPM_PWM0, 0, 0);
  pwm_issue_shadow_register_lock_event(HPM_PWM0);
  pwm_start_counter(HPM_PWM0);
  //
  pwm_get_default_cmp_config(HPM_PWM0, &cmp_cfg);
  cmp_cfg.mode = pwm_cmp_mode_output_compare;
  cmp_cfg.cmp = 0; // init duty 0%
  cmp_cfg.update_trigger = pwm_shadow_register_update_on_modify;

  pwm_setup_waveform(HPM_PWM0, 4, &pwm_cfg, 4, &cmp_cfg, 1);
  pwm_setup_waveform(HPM_PWM0, 5, &pwm_cfg, 5, &cmp_cfg, 1);
  pwm_setup_waveform(HPM_PWM0, 6, &pwm_cfg, 6, &cmp_cfg, 1);

  pwm_start_counter(HPM_PWM0);

  pwm_enable_output(HPM_PWM0, 4);
  pwm_enable_output(HPM_PWM0, 5);
  pwm_enable_output(HPM_PWM0, 6);

  rgb_pwm_inited = true;
}
void board_set_rgbled_color(float r, float g, float b) {
  if (!rgb_pwm_inited) {
    board_init_rgbled();
  }

  rgb_last_r = r;
  rgb_last_g = g;
  rgb_last_b = b;

  pwm_update_duty_edge_aligned(HPM_PWM0, 6, r);
  pwm_update_duty_edge_aligned(HPM_PWM0, 5, g);
  pwm_update_duty_edge_aligned(HPM_PWM0, 4, b);
}
//
static bool buzzer_pwm_inited = false;
static uint32_t buzzer_reload;
void board_init_buzzer(void) {
  pwm_config_t pwm_cfg;
  pwm_cmp_config_t cmp_cfg;
  // init pwm pins
  init_buzzer_pwm_pin();
  //
  uint32_t src_clk = clock_get_frequency(clock_mot0);
  /* Default 2 kHz, avoid division by zero */
  uint32_t target_hz = 2000U;
  buzzer_reload = (src_clk / target_hz) - 1U;

  /* Stop counting and prevent interference from old configurations */
  pwm_stop_counter(HPM_PWM0);
  pwm_get_default_pwm_config(HPM_PWM0, &pwm_cfg);
  pwm_cfg.enable_output = true;
  pwm_cfg.invert_output = false;
  pwm_cfg.dead_zone_in_half_cycle = 0;

  pwm_get_default_cmp_config(HPM_PWM0, &cmp_cfg);
  cmp_cfg.mode = pwm_cmp_mode_output_compare;
  cmp_cfg.update_trigger = pwm_shadow_register_update_on_modify;
  cmp_cfg.cmp = buzzer_reload / 2; /* 50% duty */

  /* Write reload & initial value */
  pwm_set_reload(HPM_PWM0, 0, buzzer_reload);
  pwm_set_start_count(HPM_PWM0, 0, 0);

  /* Configure output channel 7 using CMP7 */
  pwm_setup_waveform(HPM_PWM0, 7, &pwm_cfg, 7, &cmp_cfg, 1);

  /* Latch shadow -> active */
  pwm_issue_shadow_register_lock_event(HPM_PWM0);

  pwm_start_counter(HPM_PWM0);
  pwm_enable_output(HPM_PWM0, 7);

  buzzer_pwm_inited = true;
}
void board_set_buzzer_freq(bool enable, uint32_t freq_in_hz) {
  if (!enable || (freq_in_hz == 0)) {
    pwm_disable_output(HPM_PWM0, 7);
    /*
     * PB07 shares the PWM0 counter with RGB. When the buzzer is disabled,
     * restore PWM0 to RGB. Normal configuration to prevent the RGB breathing
     * from becoming stiff due to frequency changes from the buzzer.
     */
    board_init_rgbled();
    board_set_rgbled_color(rgb_last_r, rgb_last_g, rgb_last_b);
    buzzer_pwm_inited = false;
    return;
  }

  /* force configure the channels when enabling the buzzer 7 */
  board_init_buzzer();

  uint32_t src_clk = clock_get_frequency(clock_mot0);
  buzzer_reload = (src_clk / freq_in_hz) - 1U;

  pwm_stop_counter(HPM_PWM0);
  pwm_set_reload(HPM_PWM0, 0, buzzer_reload);
  pwm_set_start_count(HPM_PWM0, 0, 0);

  /* 50% duty，new cmp = reload/2 */
  pwm_update_raw_cmp_edge_aligned(HPM_PWM0, 7, buzzer_reload / 2);

  pwm_issue_shadow_register_lock_event(HPM_PWM0);
  pwm_start_counter(HPM_PWM0);
  pwm_enable_output(HPM_PWM0, 7);
  // restore rgb led state
  board_set_rgbled_color(rgb_last_r, rgb_last_g, rgb_last_b);
}

void board_init_imuheater(void) { init_imuheater_pwm_pin(); }
void board_set_imuheater_power(uint8_t power_percent) {
  // TODO
}

void board_init_pinsocket_pwmout(void) { init_pinsocket_pwm_pins(); }
void board_set_pinsocket_pwmout(uint8_t channel, uint32_t freq_in_hz,
                                float duty_cycle_percent) {
  // TODO
}

void board_init_user_key(void) { init_user_key_pin(); }
bool board_get_user_key_status(void) {
  return gpio_read_pin(HPM_GPIO0, GPIO_DI_GPIOY, 3) == 0;
}

void board_init_user_sw(void) { init_user_sw_pin(); }
bool board_get_user_sw_status(void) {
  return gpio_read_pin(HPM_GPIO0, GPIO_DI_GPIOY, 4) != 0;
}

// board delay functions
void board_delay_us(uint32_t us) { clock_cpu_delay_us(us); }

void board_delay_ms(uint32_t ms) { clock_cpu_delay_ms(ms); }
// TODO Remove - hpm5300evk config，if not use hpm5300evk
void board_init_gpio_pins(void) {
  init_gpio_pins();
  gpio_set_pin_input(BOARD_APP_GPIO_CTRL, BOARD_APP_GPIO_INDEX,
                     BOARD_APP_GPIO_PIN);
}

void board_init_led_pins(void) {
  init_led_pins_as_gpio();
  gpio_set_pin_output_with_initial(BOARD_LED_GPIO_CTRL, BOARD_LED_GPIO_INDEX,
                                   BOARD_LED_GPIO_PIN, BOARD_LED_OFF_LEVEL);
}
